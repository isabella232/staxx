defmodule Staxx.Testchain do
  @moduledoc """
  Default module for controlling different EVM's
  """

  require Logger

  alias Staxx.Testchain.EVM
  alias Staxx.Testchain.{SnapshotDetails, SnapshotManager}
  alias Staxx.Store.Models.Chain, as: ChainRecord
  alias Staxx.Utils

  @data_file_name "evm_data.bin"

  @typedoc """
  Chain EVM type.

  Available types are:
   - `:ganache` -  Ganache blockchain
   - `:geth` - Geth evm
   - `:geth_vdb` - Special geth evm version from https://github.com/vulcanize/go-ethereum
   - `:parity` - Parity evm
  """
  @type evm_type :: :ganache | :geth | :geth_vdb | :parity

  @typedoc """
  Big random number generated by `unique_id/0` that identifiers new chain id
  """
  @type evm_id :: binary()

  @doc """
  Generate uniq ID

  It also checks if such ID exist in runing processes list
  and checks if chain db exist for this `id`
  """
  @spec unique_id() :: evm_id()
  def unique_id() do
    <<new_unique_id::big-integer-size(8)-unit(8)>> = :crypto.strong_rand_bytes(8)
    new_unique_id = to_string(new_unique_id)

    with nil <- get_pid(new_unique_id),
         nil <- ChainRecord.get(new_unique_id),
         false <- File.exists?(evm_db_path(new_unique_id)) do
      new_unique_id
    else
      _ ->
        unique_id()
    end
  end

  @doc """
  Check if testchain is alive and running
  """
  @spec alive?(evm_id()) :: boolean()
  def alive?(id) do
    id
    |> get_pid()
    |> case do
      nil ->
        false

      pid ->
        Process.alive?(pid)
    end
  end

  @doc """
  Load testchain details from DB.
  `nil` will be returned in case of missing record.
  """
  @spec info(evm_id) :: ChainRecord.t() | nil
  def info(id),
    do: ChainRecord.get(id)

  @doc """
  Load list of available testchains for given `user_id`.
  """
  @spec list(pos_integer | nil) :: [ChainRecord.t()]
  def list(user_id),
    do: ChainRecord.list(user_id)

  @doc """
  Removes chain data if chain is already stopped.
  If chain is running - error will be returned.
  """
  @spec remove(evm_id()) :: :ok | {:error, term}
  def remove(id) do
    id
    |> alive?()
    |> case do
      true ->
        {:error, "chain have to be stopped for removing data"}

      false ->
        EVM.clean(id)
    end
  end

  @doc """
  Generates new chain snapshot and places it into given path
  If path does not exist - system will try to create this path

  **Note** this spanshot will be taken based on chain files.

  Function will return `:ok` and will notify system after snapshot will be made.
  So you will have to wait for `:snapshot_taken` event and `:status_changed` with `%{status: :ready}`
  to catch finish of snapshot taking process.
  Also all snapshot details will be sent as data to `:snapshot_taken` event.
  """
  @spec take_snapshot(evm_id(), binary) :: :ok | {:error, term()}
  def take_snapshot(id, description \\ ""),
    do: GenServer.cast(get_pid!(id), {:take_snapshot, description})

  @doc """
  Revert previously generated snapshot.
  For `ganache` chain you could provide `id` for others - path to snapshot
  """
  @spec revert_snapshot(evm_id(), SnapshotDetails.t() | binary) :: :ok | {:error, term()}
  def revert_snapshot(id, snapshot_id) when is_binary(snapshot_id) do
    snapshot_id
    |> SnapshotManager.by_id()
    |> case do
      nil ->
        {:error, "No snapshot exist with id: #{snapshot_id}"}

      %SnapshotDetails{} = details ->
        revert_snapshot(id, details)
    end
  end

  def revert_snapshot(id, %SnapshotDetails{} = snapshot) do
    case SnapshotManager.exists?(snapshot) do
      false ->
        {:error, "Snapshot not exist"}

      true ->
        GenServer.cast(get_pid!(id), {:revert_snapshot, snapshot})
    end
  end

  def revert_snapshot(_id, _), do: {:error, "Wrong snapshot details"}

  @doc """
  Write any additional information to `evm_data.json` file into chain DB path.
  Thi sfile will be used any any other processes for storage info in there.
  """
  @spec write_external_data(evm_id(), term) :: :ok | {:error, term}
  def write_external_data(_id, nil), do: :ok

  def write_external_data(id, data) do
    path = evm_db_path(id)

    with true <- File.exists?(path),
         encoded <- :erlang.term_to_binary(data, compressed: 1),
         file_path <- Path.join(path, @data_file_name),
         :ok <- Utils.file_write(file_path, encoded) do
      :ok
    else
      false ->
        {:error, "No chain path exists"}

      {:error, err} ->
        {:error, err}

      err ->
        err
    end
  end

  @doc """
  Read all additional information that is stored with chain
  In case of file missing `{:ok, nil}` will be returned
  """
  @spec read_external_data(evm_id()) :: {:ok, nil | map} | {:error, term}
  def read_external_data(id) do
    path =
      id
      |> evm_db_path()
      |> Path.join(@data_file_name)

    with true <- File.exists?(path),
         {:ok, content} <- File.read(path),
         data <- :erlang.binary_to_term(content, [:safe]) do
      {:ok, data}
    else
      false ->
        {:ok, nil}

      {:error, err} ->
        {:error, err}
    end
  end

  @doc """
  Load list of evms version used in app
  """
  @spec version() :: binary
  def version() do
    {:ok, v} = :application.get_key(:testchain, :vsn)
    "Application version: #{to_string(v)}"
  end

  @doc """
  Generate EVM DB path for chain
  """
  @spec evm_db_path(evm_id()) :: binary
  def evm_db_path(id) do
    Application.get_env(:testchain, :base_path, "/tmp")
    |> Path.expand()
    |> Path.join(id)
  end

  @doc """
  Staxx host
  """
  @spec host() :: binary
  def host(),
    do: Application.get_env(:testchain, :host, "host.docker.internal")

  @doc """
  Get NATS url
  """
  @spec nats_url() :: binary
  def nats_url() do
    %{host: host, port: port} = Application.get_env(:testchain, :nats)
    "nats://#{host}:#{port}"
  end

  # Try lo load pid by given id
  defp get_pid(id) do
    id
    |> EVM.via()
    |> GenServer.whereis()
  end

  # Same as `get_pid\1` but will raise in case of issue
  defp get_pid!(id) do
    case get_pid(id) do
      nil ->
        raise "No pid found"

      pid ->
        pid
    end
  end
end
